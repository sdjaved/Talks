#!/usr/bin/env pinpoint
[font=Sans 40px]
[text-color=rgb(250, 250, 250)]
[center]
[img/bg.jpg]
[shading-opacity=0.8]
[fit] # default is fit, there's also fill.
# use <b> for stroken

--[font=Sans 60px]
<b>GStreamer for Mobile Platforms: Android and iOS</b>

GStreamer Conference 2013, Edinburgh

Andoni Morales Alastruey

--[font=Sans 35px]
<b> Who am I ?</b>

Andoni Morales Alastruey amorales@fluendo.com

â€¢ Working for Fluendo

â€¢ GStreamer contributor since 2008

â€¢ LongoMatch, a sports video analysis software
  using GStreamer (www.longomatch.org)

--[font=Sans 60px]

1. Platform and development tools

2. Platform plugins

3. Building GStreamer with cerbero

4. Integration with the build infrastructure

5. Installing GStreamer and creating your first application

--[font=Sans 60px]
<b>1. Platforms and the development tools</b>

--[font=Sans 60px]
<b>Android</b>

--
â€¢ Programming language: java

â€¢ SDK:
   â€¢ Android SDK Manager
   â€¢ ADB (command line tool to communicate with devices)
   â€¢ Emulator, ant, and other tools for development

â€¢ NDK: set of cross-toolchains that can generate native binaries

â€¢ JNI: managed code (Java programming language) to interact with
   native code (written in C/C++)

â€¢ Architectures: MIPS, x86, ARMv5TE,
   ARMv7-A (hardware FPU, Thumb-2, NEON)

--

â€¢ Support for shared libraries (limited per process)

â€¢ Android Market:
   â€¢ Unique setup fee for developers 25$
   â€¢ Alfa, Beta testing and staged rollouts

â€¢ Development in Linux, Windows and OS X

â€¢ Cheap devices for testing

--
# A different install from the SDK

<b> The NDK (Native Development Kit) </b>

 â€¢ Toolchains (compiler, linker, etc...) for the different target
   architectures

 â€¢ ndk-build: build system to compile native code and embed it the .apk

 â€¢ ndk-gdb: remote GDB debugger

 â€¢ Provide a limited API:
   â€¢ libc (C library) headers
   â€¢ libm (math library) headers
   â€¢ JNI interface headers
   â€¢ libz (Zlib compression) headers
   â€¢ liblog (Android logging) header
   â€¢ OpenGL ES 1.1 and OpenGL ES 2.0 headers
   â€¢ libjnigraphics (Pixel buffer access) header
   â€¢ A Minimal set of headers for C++ support
   â€¢ OpenSL ES native audio libraries
   â€¢ Android native application APIS

--
# We can do most of the things natively
<b>Android Multimedia Stack</b>

  â€¢ OpenGL ES 2.0 + EGL (video sink)

  â€¢ OpenSL ES (audio sink)

  â€¢ android.media.MediaCodec
     (video/audio decoder/encoder)

  â€¢ android.hardware.Camera (video source)

--
# I miss more native API.
<b>Android Multimedia Stack</b>

# Video players and camera capturers
â€¢ Good multimedia API for playback and capture and
   rendering

# Audio: AAC, MP3, FLAC, Vorbis, AMR, Midi, PCM
# Video: H264, H264, AVC, VP8
# Muxers: WebM, Matroska, MP4, OGG, Mpeg-TS
â€¢ Support for most common audio and video formats

â€¢ Software and hardware decoders/encoders

# RTSP, HTTP, HLS
â€¢ And a few streaming protocols (RTSP, HTTP, HLS)

--[font=Sans 60px]
# If you have ever considered developing an app for iOS,
# please reconsider
<b>iOS</b>

â€¢ Programing language: Objective C

â€¢ We can use the GStreamer C API directly

â€¢ XCode:
   â€¢ Cross toolchain
   â€¢ Frameworks

â€¢ Architectures:
  â€¢ Emulator: x86
  â€¢ Devices: ARMv6 and ARMv7

â€¢ Static linking

--
<b>iOS</b>

â€¢ Some parts of the API are not available in the emulator

# You can only access Assets or files in the app sandbox
â€¢ Applications sandboxing is insane

â€¢ App Store:
   â€¢ 100$ per developer... per year!!!
   â€¢ You can't test your code in a real device without
      a developer account :(
   â€¢ Deploying apps to the App store is a long process,
     make sure you have everything tested.

â€¢ Development in OS X only

â€¢ Devices are not cheap

â€¢ Their business model is clear: $$$$$$

--
# Regarding the build environment

<b> XCode </b>

 â€¢ IDE: similar development environment to OS X

 â€¢ Cross toolchain for the emulator and the device

 â€¢ iOS Frameworks

 â€¢ We can use the GStreamer C API

--
#EAGL Is the iOS Implementation of an OpenGL ES Rendering Context

# No API for hardware decoders SUCKS!
<b>iOS Multimedia Stack</b>

  â€¢ OpenGL ES 2.0 + EAGL (video sink)

  â€¢ CoreAudio Remote I/O Audio Unit (audio sink)

  â€¢ No API for hardware decoders/encoders!
    (VideoToolBox is a private Framework for iOS)

  â€¢ AVFoundation (video source and URI decoder)

--
<b>iOS Multimedia Stack</b>

# Video players and camera capturers
â€¢ Good API for source and sink elements

â€¢ Hardware decoding is limited to file and http uri's
  in a supported container

â€¢ Only a few format supported

--[font=Sans 60px]

<b> Issues we have to deal with on these platforms </b>

--
# GStreamer itself only depends on glib, libxml2, libffi and libz,
# but plugins pull-in many dependencies
â€¢ Plugin-based architecture -> lots of shared libraries

# android's dynamic linker has a hard-coded limit on the number
# of .so files (shared libraries and/or plugins) you can load in a single process.
# Android's linker is limited to 64, 96 and 128 shared libraries
â€¢ Android's dynamic linker limits the number of shared
   libraries per process.

â€¢ iOS only supports static linking

# Including all plugins we have 262 shared libraries
â€¢ We have more than 262 shared libraries ðŸ˜“

â€¢ Embedding GStreamer in a transparent way
   for developers isn't easy

# The LGPL requires a re-linking mechanism for statically linked
# libraries.
â€¢ Legal constraints with the LGPL and static linking.

# Other API's are not even available in C like the
# MediaCodec API
â€¢ The NDK is limited to the C library (BIONIC) and
   a few other libraries (OpenSL and OpenGL)

â€¢ No hardware decoders in iOS

â€¢ We need to use static plugins

--[font=Sans 60px]
<b>2. Platform plugins</b>
# Important: use only public API!!!
# add missing features

--[font=Sans 60px]
OpenGL ES + EGL/EAGL  Video Sink

eglglessink gst-plugins-gl

--
<b>OpenGL ES + EGL/EAGL  Video Sink</b>

â€¢ Available for Android and iOS

â€¢ Public and native API

# OpenGL not really made for video display but usable
# Replacement for old surfaceflinger, non-public API
â€¢ Supports hardware accelerated colorspace
   conversion, scaling

# YUV, RGB, shaders
â€¢ Usable on all Android (since 2.3) and iOS devices

# Also other platforms with OpenGL ES/EGL
# Available since Android Gingerbread (2.3)
â€¢ Works like any other GStreamer video sink

â€¢ Requires the application to provide a surface
   using the GstVideoOverlay interface

â€¢ Can provide a Surface + SurfaceTexture for
   direct rendering in Android with amcvideodec


--[font=Sans 60px]
<b> Android </b>

--[font=Sans 60px]
OpenSL ES Audio Sink/Source

openslessink openslessrc
--
# This API is the only public native API for
# audio, it replaces the old audioflinger
# that uses private API
<b>OpenSL ES Audio Sink/Source</b>

â€¢ OpenSL ES only public native API for
   audio on Android

# Khronos standard (think: OpenGL, OpenMAX)
# Replace old audioflinger based sink, non-public API
â€¢ Very limited implementation available on Android

# Very complex and powerful standard though, IMHO overengineered
#   Mono, S16, 16kHz recording
#   Mono/Stereo, U8/S16, up to 48kHz playback
#   No device selection or any other more advanced features
â€¢ Usable on all Android devices

# Available since Android Gingerbread (2.3)
â€¢ Uses Android-specific API extensions

--[font=Sans 60px]
android.media.MediaCodec Wrapper

amvvideodec amcaudiodec

--
<b> Media Codec API</b>

â€¢ Be able to use device's codecs
# Hardware acceleration, no worries about patent licenses

â€¢ Uses Java API via JNI
# OpenMAX AL another option, very limited on Android
#   only MPEGTS decoding
# Very simple and powerful API

â€¢ Java/JNI not performance problem
# Very few method calls per frame
# MediaCodec only small JNI wrapper around stagefright (C++)

â€¢ Usable on all Android devices (Jelly Bean 4.1)
# Available since Android Jelly Bean (4.1)

â€¢ Bad colorspace definitions (vendor-specific colorspaces):
   QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka

â€¢ Supports direct rendering with GL sinks

--
<b> Media Codec API</b>

â€¢ Implemented: audio/video decoders

# Hardware and software codecs
# Tested so far on TI Ducati and NVidia Tegra3
â€¢ Encoders: patch in bugzilla

# Only wotks with some devices
â€¢ 1080p h264 easily possible, impossible in software

â€¢ Supported video codecs:
   h264/AVC, MPEG4, h263, MPEG2 and VP8

â€¢ Supported audio codecs:
   AAC, MP3, AMR-NB/WB, A-Law, Âµ-Law,
   Vorbis and FLAC

--
<b>androidcamerasrc? </b>

â€¢ No source element for now

â€¢ Can be easilly implemented with the Camera Java API

â€¢ Easy to implement with appsrc for now :)


--[font=Sans 60px]
<b> iOS </b>

--
AVFoundation video source

avfvideosrc

--
<b>AVFoundation video source</b>

â€¢ Output formats: NV12, UYVY, YUY2

â€¢ Output resolutions: 192x144 352x288 480x360 640x480
   1280x720 1980x1080

â€¢ Supports device selection

--[font=Sans 60px]

AVAssetReader URI decoder

iosavassetsrc

--
# Only way we have found to support hardware decoders in iOS
# It can only decode supported formats and protocos
# Doesn't not cover many of the use cases used in GStreamer
# Only useful for Playback


â€¢ AVAssetReader API  (in AVFoundation)

â€¢ All-in-one source + demuxer + decoder:

  gst-launch -v -m iosavassetsrc uri="file://movie.mp4" ! autovideosink

â€¢ Can read from iOS Assets (ipod-library://, file://)

â€¢ Takes advantage of the hardware decoders

â€¢ But only works with the supported protocols and formats


--[font=Sans 60px]

CoreAudio

osxaudiosrc

--
â€¢ Same element used in OS X

â€¢ Uses the RemoteIO backend instead of HAL

â€¢ Does not support device selection in OS X

--[font=Sans 60px]

3. Building GStreamer with cerbero

--
<b> Cerbero </b>

# We use cerbero, a build system developped for building the GStreamer SDK
# Supports many platforms, cross-compilation and toolchain configuration.
â€¢ We use a build system named Cerbero:
   3-headed dog which guards the doors of the Underwold
   (Linux, Windows, OS X)

â€¢ Same build system used in all platforms.

# Makefile, autotools and CMake. This saved us a lot ot time
# compared to the old approach of porting the build to ndk-build
â€¢ Re-use of upstream packaging system.

â€¢ Native packaging:
   Windows .msi, OS X .pkg, RPM and DEB

â€¢ Easy to maintain

â€¢ Easy to add new packages or 3rd party plugins

--
<b> Cerbero </b>

â€¢ Bootstrapping facilities

â€¢ Platform definition files:
   very easy to add support for new platforms/toolchains

â€¢ Build config files:
   configures build for differents uses

--[shading-opacity=0.9000000][no-markup][text-color=white][font=Monospace 25px]

# Shows how simple and fast is rebuilding the sdk
$ git clone git://anongit.freedesktop.org/gstreamer/sdk/cerbero

$ cerbero -c config/cross-android.cbc bootstrap

$ cerbero -c config/cross-android.cbc package gstreamer-1.0

--
Available configuration files:

<b>Android</b>

â€¢ cross-android.cbc: Android armv5
â€¢ cross-android-armv7.cbc: Android armv7
â€¢ cross-android-x86.cbc: Android armv7

<b>iOS</b>

â€¢ cross-ios-x86.cbc: iOS x86 (emulator)
â€¢ cross-ios-armv7.cbc: iOS armv7 (devices)
â€¢ cross-ios-universal.cbc: iOS armv7+x86

--[font=Sans 60px]
4. Integration with the build infrastructure
   (embedding GStreamer)

# Next I will try to explain how we managed to integrate
# GStreamer with the native build process, in a way
# that's transparent to users
--

<b>Android</b>

# Force to use static plugins due to limitaion in number of shared
# libraries per process
â€¢ Static plugins

# Static libraries built with -DPIC and -fPIC
# Static linking inly includes oject libraries that
# are actually.
â€¢ Static linking with re-locatable archives.

# Easy to re-distribute and load in applications
â€¢ A single shared library with everything:
    libgstreamer_android.so

â€¢ Integration with ndk-build to link this shared library:
    â€¢ Complies with the LGPL requirement.
    â€¢ Allows selecting only the plugins being used.

--[img/app.png]
# What the application sees is  single shared library
# Call LoadLibrary

--[font=Sans 60px]

# A set of makefiles that extend nkd-build's core to generate
# libgstreamer_android.so and link it to the application
<b>Android integration with the NDK</b>

# From the point of view of application developers we tried
# to make things as easy as possible.
# Example of Android.mk from the Android NDK samples
--[shading-opacity=0.9000000][no-markup][text-color=white][font=Monospace 40px]

LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE    := hello-jni
LOCAL_SRC_FILES := hello-jni.c
include $(BUILD_SHARED_LIBRARY)

include $(CLEAR_VARS)

# jni/Android.mk modified to include GStreamer
--[shading-opacity=0.9000000][no-markup][text-color=white][font=Monospace 60px]
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE    := hello-jni
LOCAL_SRC_FILES := hello-jni.c
LOCAL_SHARED_LIBRARIES := gstreamer_android
include $(BUILD_SHARED_LIBRARY)

include $(CLEAR_VARS)

include $(GSTREAMER_NDK_BUILD_PATH)/plugins.mk

GSTREAMER_ROOT := /home/cerbero/android_arm
GSTREAMER_PLUGINS =  $(GSTREAMER_PLUGINS_CORE)\
                     $(GSTREAMER_PLUGINS_CODECS)
GSTREAMER_EXTRA_DEPS := json-glib-1.0

include $(GSTREAMER_NDK_BUILD_PATH)/gstreamer.mk

# jni/Android.mk modified to include GStreamer
--[shading-opacity=0.9000000][no-markup][text-color=white][font=Monospace 60px]

(Application.mk)
APP_ABI = armeabi armeabi-v7a

(Android.mk)
ifeq ($(TARGET_ARCH_ABI), armeabi)
  GSTREAMER_ROOT := /home/gstreamer/android_arm
else ifeq ($(TARGET_ARCH_ABI), armeabi-v7a)
  GSTREAMER_ROOT := /home/gstreamer/android_armv7
else
  $(error "Unsupported ABI $(TARGET_ARCH_ABI)")
endif

--
# gstreamer_android.c:
# redirects GStreamer logs to logcat and adds an entry
# point to initialize GStreamer and register static plugins

â€¢ Generate gstreamer_android.c

â€¢ Get the link deps based on the input plugins

â€¢ Compile gstreamer_android.c

â€¢ Link libgstreamer_android.so with
   gstreamer_android.o and the deps

â€¢ Copies fonts config and glue code in Java

--[img/build_steps.png]

# Libraries used from the C backend must be explicetly listed
# to include the whole archive with --whole-archive, otherwise
# the linker will not include the object files as no symbol
# is used by the gstreamer plugins.
--
â€¢ We use libtool libraries to resolve link deps

# Requires a unix-like shell on windows
â€¢ Libtool can't be used for portability issues

# equivalent to libtool --comand=link -static-libtool-libs
â€¢ A small libtool replacement in GNU Makefile + sed

      â€¢ Portable (works on Windows too)

# We can install the SDK everywhere as libtool is relocatable
      â€¢ Supports relocations of .la files

      â€¢ Much faster than libtool

--
<b>iOS</b>

# Static libraries built with -DPIC and -fPIC
# Static linking inly includes oject libraries that
# are actually used.
â€¢ Static linking

# Easy to re-distribute and load in applications
â€¢ iOS Framework to work with XCode

â€¢ Big archive with all the static libraries

â€¢ Selection of plugins with #ifdef's registering static plugins

â€¢ The strip step takes cares of removing the extra archives
   and symbols that are not used by the application

--[shading-opacity=0.9000000][no-markup][text-color=white][font=Monospace 60px]
(gst_ios_init.h)

\#define GST_IOS_PLUGINS_CORE
//#define GST_IOS_PLUGINS_CAPTURE
//#define GST_IOS_PLUGINS_CODECS_RESTRICTED
//#define GST_IOS_PLUGINS_ENCODING
//#define GST_IOS_PLUGINS_DVD
//#define GST_IOS_PLUGINS_CODECS_GPL
//#define GST_IOS_PLUGINS_NET_RESTRICTED
//#define GST_IOS_PLUGINS_SYS
//#define GST_IOS_PLUGINS_VIS
\#define GST_IOS_PLUGINS_PLAYBACK
\#define GST_IOS_PLUGINS_EFFECTS
\#define GST_IOS_PLUGINS_CODECS
\#define GST_IOS_PLUGINS_NET

--[shading-opacity=0.9000000][no-markup][text-color=white][font=Monospace 60px]
\#include "gst_ios_init.h"

\#if defined(GST_IOS_PLUGIN_COREELEMENTS) || defined(GST_IOS_PLUGINS_CORE)
  GST_PLUGIN_STATIC_DECLARE(coreelements);
\#endif

void
gst_ios_init (void)
{
  GstPluginFeature *plugin;
  GstRegistry *reg;
  NSString *resources = [[NSBundle mainBundle] resourcePath];
  NSString *tmp = NSTemporaryDirectory();

  const gchar *tmp_dir = [tmp UTF8String];
  [...]
  g_setenv ("TMP", tmp_dir, TRUE);
  [...]

  gst_init (NULL, NULL);
  #if defined(GST_IOS_PLUGIN_COREELEMENTS) || defined(GST_IOS_PLUGINS_CORE)
    GST_PLUGIN_STATIC_REGISTER(coreelements);
  #endif

  /* Lower the ranks of filesrc and giosrc so iosavassetsrc is
   * tried first in gst_element_make_from_uri() for file:// */
  reg = gst_registry_get_default();
  plugin = gst_registry_lookup_feature(reg, "filesrc");
  if (plugin)
    gst_plugin_feature_set_rank(plugin, GST_RANK_SECONDARY);
}

--[font=Sans 60px]

5. Installing GStreamer and creating your first application

--
<b> Android </b>

â€¢ Distributed with a tarball

â€¢ Includes:
  â€¢ Headers
  â€¢ Static libraries (.a)
  â€¢ Libtool librarires (.la)
  â€¢ NDK integration makefiles

â€¢ Only requires to extract the tarball

â€¢ Create a project in Eclipse and add native support
  projectâ†’Android Toolsâ†’Add Native Support

â€¢ Finally edit your Android.mk with the path to the root

# honestly I think th eintegration with JNI can be trikcy
# we need  proper bindings!
--[shading-opacity=0.9000000][no-markup][text-color=white][font=Monospace 60px]
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE    := hello-jni
LOCAL_SRC_FILES := hello-jni.c
LOCAL_SHARED_LIBRARIES := gstreamer_android
include $(BUILD_SHARED_LIBRARY)

include $(CLEAR_VARS)

include $(GSTREAMER_NDK_BUILD_PATH)/plugins.mk

GSTREAMER_ROOT := /home/cerbero/android_arm
GSTREAMER_PLUGINS =  $(GSTREAMER_PLUGINS_CORE)\
                     $(GSTREAMER_PLUGINS_CODECS)
GSTREAMER_EXTRA_DEPS := json-glib-1.0

include $(GSTREAMER_NDK_BUILD_PATH)/gstreamer.mk

--

<b>iOS</b>

â€¢ Distributed as DMG image file

â€¢ Contains a .pkg to install the framework
   and a folder with the tutorials

â€¢ The .pkg installs the Framework and the XCode templates

--[img/1.png]
--[img/2.png]
--[img/3.png]
--[img/4.png]
--[img/5.png]
--[img/6.png]

--[img/final_bg.jpg]

Â¿Questions?

--[img/final_bg.jpg]

Thanks!
